#!/usr/bin/env python3
"""
listener_with_response.py

Écoute sur un port (9001 par défaut). Pour chaque connexion :
 - envoie un message (par défaut "ls\n")
 - attend la réponse du pair (avec timeout / idle timeout)
 - affiche la réponse reçue
 - ferme la connexion et repasse en écoute

Usage:
    python3 listener_with_response.py
    python3 listener_with_response.py --host 127.0.0.1 --port 9001 --message "ls\n" --recv-timeout 5 --idle-timeout 0.5
"""

import socket
import argparse
import signal
import sys
import time

def serve(bind_host: str, bind_port: int, msg: bytes, recv_timeout: float, idle_timeout: float, max_bytes: int):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((bind_host, bind_port))
    sock.listen(5)
    print(f"[+] Listening on {bind_host}:{bind_port} — Ctrl+C to stop")

    def handle_sigint(signum, frame):
        print("\n[+] Shutting down listener.")
        try:
            sock.close()
        except Exception:
            pass
        sys.exit(0)

    signal.signal(signal.SIGINT, handle_sigint)
    signal.signal(signal.SIGTERM, handle_sigint)

    while True:
        try:
            conn, addr = sock.accept()
        except OSError:
            break
        peer = f"{addr[0]}:{addr[1]}"
        print(f"[+] Connection from {peer}")
        try:
            conn.settimeout(3.0)  # short timeout for send/initial ops
            # send the message
            try:
                conn.sendall(msg)
                print(f"[>] Sent to {peer!s}: {msg.decode(errors='replace').rstrip()!s}")
            except Exception as e:
                print(f"[-] Error sending to {peer}: {e}")
                try:
                    conn.close()
                except Exception:
                    pass
                continue

            # now receive response
            # we'll use small recv loop with idle timeout logic
            conn.settimeout(recv_timeout)  # overall blocking recv timeout
            received = bytearray()
            start = time.time()
            last_data_time = None
            while True:
                try:
                    chunk = conn.recv(4096)
                except socket.timeout:
                    # no data within recv_timeout window
                    break
                except Exception as e:
                    print(f"[-] Recv error from {peer}: {e}")
                    break

                if not chunk:
                    # connection closed by peer
                    break

                received.extend(chunk)
                last_data_time = time.time()

                # quick exit if we've got enough
                if len(received) >= max_bytes:
                    print(f"[!] Reached max_bytes ({max_bytes}), stopping read.")
                    break

                # a short non-blocking idle wait to gather more fragments
                # temporarily set a small timeout to check for immediate more data
                try:
                    conn.settimeout(idle_timeout)
                    more = conn.recv(1)
                    if more:
                        received.extend(more)
                        last_data_time = time.time()
                        # restore recv_timeout for main loop
                        conn.settimeout(recv_timeout)
                        continue
                    else:
                        break
                except socket.timeout:
                    # no extra byte within idle_timeout -> assume peer finished sending
                    conn.settimeout(recv_timeout)
                    break
                except Exception:
                    # ignore and continue main loop
                    conn.settimeout(recv_timeout)
                    break

            # print/log the response
            if received:
                try:
                    text = received.decode('utf-8', errors='replace')
                except Exception:
                    text = str(received)
                print(f"[<] Response from {peer} (len={len(received)}):")
                print(text.rstrip("\n"))
            else:
                print(f"[<] No response received from {peer}")

        finally:
            try:
                conn.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            conn.close()
            print(f"[+] Closed connection {peer}\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Listener that sends a message then reads a response.")
    parser.add_argument("--host", default="0.0.0.0", help="Address to bind to (default 0.0.0.0).")
    parser.add_argument("--port", type=int, default=9001, help="Port to listen on (default 9001).")
    parser.add_argument("--message", default="ls ~\n", help="Message to send (default 'ls\\n').")
    parser.add_argument("--recv-timeout", type=float, default=5.0, help="Blocking recv timeout in seconds (default 5.0).")
    parser.add_argument("--idle-timeout", type=float, default=0.5, help="Short idle timeout to decide end-of-response (default 0.5s).")
    parser.add_argument("--max-bytes", type=int, default=200000, help="Maximum bytes to collect from peer (default 200000).")
    args = parser.parse_args()

    out_msg = args.message.encode("utf-8")
    serve(args.host, args.port, out_msg, args.recv_timeout, args.idle_timeout, args.max_bytes)
