#!/usr/bin/env python3
"""
activemq_version_check.py

Connect to an ActiveMQ host (HTTP console 8161 and broker OpenWire 61616),
try to extract version strings, and compare against vulnerable version ranges
related to CVE-2023-46604.

Usage:
    python3 activemq_version_check.py <host_or_ip> [--http-port 8161] [--broker-port 61616]
    python3 activemq_version_check.py 192.168.1.12

Requires:
    requests  (install with `pip install requests`)
"""

import argparse
import re
import socket
import sys
import time

try:
    import requests
except Exception:
    requests = None

# --- Configurable defaults ---
DEFAULT_HTTP_PORT = 8161
DEFAULT_BROKER_PORT = 61616
HTTP_TIMEOUT = 5.0
SOCKET_TIMEOUT = 5.0
DEFAULT_READ_BYTES = 4096
DEFAULT_READ_LOOPS = 3

# --- Vulnerability logic for CVE-2023-46604 ---
# Vulnerable ranges (5.x branch):
# - minor < 15 -> vulnerable
# - 15.x where patch < 16 -> vulnerable
# - 16.x where patch < 7 -> vulnerable
# - 17.x where patch < 6 -> vulnerable
# - 18.x where patch < 3 -> vulnerable

def parse_version_string(vstr):
    """
    Parse version strings like "5.16.4" or "5.16" -> returns (major, minor, patch)
    or None if cannot parse.
    """
    if not vstr or not isinstance(vstr, str):
        return None
    vstr = vstr.strip()
    m = re.search(r'(\d+)\.(\d+)\.(\d+)', vstr)
    if m:
        return (int(m.group(1)), int(m.group(2)), int(m.group(3)))
    m = re.search(r'(\d+)\.(\d+)', vstr)
    if m:
        return (int(m.group(1)), int(m.group(2)), 0)
    return None

def is_potentially_vulnerable(ver_tuple):
    if not ver_tuple: 
        return None
    major, minor, patch = ver_tuple
    if major != 5:
        return False
    if minor < 15:
        return True
    if minor == 15 and patch < 16:
        return True
    if minor == 16 and patch < 7:
        return True
    if minor == 17 and patch < 6:
        return True
    if minor == 18 and patch < 3:
        return True
    return False

# --- Extraction helpers ---
def extract_version_from_html(text):
    """
    Try common patterns in HTML to find version: 'Apache ActiveMQ 5.16.4' etc.
    If not found, fallback to first occurrence of digit patterns.
    Returns raw matched string or None.
    """
    if not text:
        return None
    # common patterns
    patterns = [
        r'Apache\s+ActiveMQ\s*([0-9]+\.[0-9]+\.[0-9]+)',
        r'ActiveMQ[\s\-\|:]+([0-9]+\.[0-9]+\.[0-9]+)',
        r'version[\s\:\=]*([0-9]+\.[0-9]+\.[0-9]+)',
        r'ActiveMQ[\s\-\|:]+([0-9]+\.[0-9]+)',
    ]
    for p in patterns:
        m = re.search(p, text, re.IGNORECASE)
        if m:
            return m.group(1)
    # fallback: first x.y.z or x.y
    m = re.search(r'([0-9]+\.[0-9]+\.[0-9]+)', text)
    if m:
        return m.group(1)
    m = re.search(r'([0-9]+\.[0-9]+)', text)
    if m:
        return m.group(1)
    return None

def clean_binary_to_text(b):
    """
    Convert bytes to str and replace non-printable characters with spaces,
    to make pattern search easier.
    """
    if b is None:
        return ''
    if isinstance(b, bytes):
        s = b.decode('utf-8', errors='replace')
    else:
        s = str(b)
    # replace non-printable characters
    s = re.sub(r'[^\x20-\x7E\r\n\t]', ' ', s)
    return s

def extract_version_from_banner(text):
    """
    Attempt to find version in a 'banner' (cleaned text).
    """
    if not text:
        return None
    patterns = [
        r'ProviderVersion\s*[:=]?\s*([0-9]+\.[0-9]+\.[0-9]+)',
        r'ProviderVersion\s*[:=]?\s*([0-9]+\.[0-9]+)',
        r'ActiveMQ\s*([0-9]+\.[0-9]+\.[0-9]+)',
        r'ActiveMQ\s*([0-9]+\.[0-9]+)',
        r'([0-9]+\.[0-9]+\.[0-9]+)',
        r'([0-9]+\.[0-9]+)',
    ]
    for p in patterns:
        m = re.search(p, text, re.IGNORECASE)
        if m:
            return m.group(1)
    return None

# --- Connection checks ---
def check_http_console(host, port=DEFAULT_HTTP_PORT, timeout=HTTP_TIMEOUT):
    result = {'port': port, 'reachable': False, 'version_raw': None, 'version': None, 'error': None}
    if requests is None:
        result['error'] = "Module 'requests' not installed"
        return result
    url = f'http://{host}:{port}/'
    try:
        resp = requests.get(url, timeout=timeout, allow_redirects=True)
    except Exception as e:
        result['error'] = f'HTTP request failed: {e}'
        return result
    result['reachable'] = True
    body = resp.text or ''
    # try body first
    ver = extract_version_from_html(body)
    # fallback: headers
    if not ver:
        for hval in resp.headers.values():
            if isinstance(hval, str):
                m = re.search(r'ActiveMQ\s*([0-9]+\.[0-9]+\.[0-9]+)', hval, re.IGNORECASE)
                if m:
                    ver = m.group(1)
                    break
    result['version_raw'] = ver
    parsed = parse_version_string(ver) if ver else None
    result['version'] = parsed
    result['vulnerable'] = is_potentially_vulnerable(parsed) if parsed else None
    return result

def check_broker_openwire(host, port=DEFAULT_BROKER_PORT, timeout=SOCKET_TIMEOUT, read_bytes=DEFAULT_READ_BYTES, loops=DEFAULT_READ_LOOPS):
    result = {'port': port, 'reachable': False, 'raw_sample': None, 'version_raw': None, 'version': None, 'error': None}
    sock = None
    try:
        sock = socket.create_connection((host, port), timeout=timeout)
        result['reachable'] = True
        sock.settimeout(timeout)
        acc = b''
        for i in range(max(1, loops)):
            try:
                chunk = sock.recv(read_bytes)
            except socket.timeout:
                break
            except Exception:
                break
            if not chunk:
                break
            acc += chunk
            # small sleep to allow server push
            time.sleep(0.05)
            # stop early if acc is reasonably large
            if len(acc) >= read_bytes * loops:
                break
        sock.close()
        if not acc:
            result['raw_sample'] = ''
            return result
        clean = clean_binary_to_text(acc)
        result['raw_sample'] = clean[:2000]
        ver = extract_version_from_banner(clean)
        result['version_raw'] = ver
        parsed = parse_version_string(ver) if ver else None
        result['version'] = parsed
        result['vulnerable'] = is_potentially_vulnerable(parsed) if parsed else None
        return result
    except Exception as e:
        result['error'] = f'socket error: {e}'
        try:
            if sock:
                sock.close()
        except Exception:
            pass
        return result

# --- CLI & printing ---
def pretty_report(host, http_res, broker_res):
    print(f"Target: {host}\n")
    # HTTP
    print(f"[HTTP Console] {http_res['port']}:")
    if http_res.get('error'):
        print(f"  Error: {http_res['error']}")
    elif not http_res['reachable']:
        print("  Unreachable")
    else:
        vr = http_res.get('version_raw')
        if vr:
            parsed = http_res.get('version')
            print(f"  Version string found: {vr} -> parsed: {parsed}")
            vuln = http_res.get('vulnerable')
            if vuln is True:
                print("  STATUS: POTENTIALLY VULNERABLE to CVE-2023-46604")
            elif vuln is False:
                print("  STATUS: Not flagged vulnerable by version check")
            else:
                print("  STATUS: Unknown vulnerability state")
        else:
            print("  ActiveMQ console reachable but version string not found in page or headers.")
    print("")
    # Broker
    print(f"[Broker OpenWire] {broker_res['port']}:")
    if broker_res.get('error'):
        print(f"  Error: {broker_res['error']}")
    elif not broker_res['reachable']:
        print("  Unreachable")
    else:
        vr = broker_res.get('version_raw')
        if vr:
            parsed = broker_res.get('version')
            print(f"  Version string found: {vr} -> parsed: {parsed}")
            vuln = broker_res.get('vulnerable')
            if vuln is True:
                print("  STATUS: POTENTIALLY VULNERABLE to CVE-2023-46604")
            elif vuln is False:
                print("  STATUS: Not flagged vulnerable by version check")
            else:
                print("  STATUS: Unknown vulnerability state")
        else:
            sample = broker_res.get('raw_sample') or ''
            sample_display = sample[:400].replace('\n', '\\n')
            print("  Banner read but no version string found.")
            if sample_display:
                print("  Cleaned sample (short):")
                print(f"    {sample_display}")
            else:
                print("  No textual banner available.")
    print("\nNote: This tool only attempts passive detection. Do not run against systems you are not authorized to test.")
    return

def main():
    p = argparse.ArgumentParser(description="ActiveMQ version detector (HTTP 8161 + broker 61616) for CVE-2023-46604 checks")
    p.add_argument("host", help="Hostname or IP of target")
    p.add_argument("--http-port", type=int, default=DEFAULT_HTTP_PORT, help="HTTP console port (default 8161)")
    p.add_argument("--broker-port", type=int, default=DEFAULT_BROKER_PORT, help="Broker port (default 61616)")
    p.add_argument("--read-bytes", type=int, default=DEFAULT_READ_BYTES, help="Bytes per recv on broker read")
    p.add_argument("--loops", type=int, default=DEFAULT_READ_LOOPS, help="Number of read loops for broker")
    args = p.parse_args()

    if requests is None:
        print("ERROR: 'requests' Python module not installed. Install with: pip install requests")
        sys.exit(2)

    http_res = check_http_console(args.host, port=args.http_port)
    broker_res = check_broker_openwire(args.host, port=args.broker_port, read_bytes=args.read_bytes, loops=args.loops)
    pretty_report(args.host, http_res, broker_res)

if __name__ == '__main__':
    main()

